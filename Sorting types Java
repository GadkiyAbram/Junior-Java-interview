Всем привет!
Решил освежить в памяти алгоритмы сортировки и их реализацию. Нашел на Хабре статью автора valemak
(https://habr.com/post/204600/), буду брать выдержки его статьи и дополнять своим кодом. Данные механизмы сортировки являются
разновидностями "сортировки обменом". Итак, приступим:

1. "Глупая" сортировка:
Просматриваем массив слева-направо и по пути сравниваем соседей. Если мы встретим пару взаимно неотсортированных элементов, то
меняем их местами и возвращаемся на круги своя, то бишь в самое начало. Снова проходим-проверяем массив, если встретили снова
«неправильную» пару соседних элементов, то меняем местами и опять начинаем всё сызнова. Продолжаем до тех пор пока массив
потихоньку-полегоньку не отсортируется.

int count = 0;                                    //завели отдельный счетчик для внешнего цикла
while (count != arr1.length){                                                
    for (int i = 0; i < arr1.length - 1; i++){
        if (arr1[i] > arr1[i + 1]){               //встретили пару неотсортированных элементов
            int temp = arr1[i];                   //ввели временную переменную для запоминания одного из элементов
            arr1[i] = arr1[i + 1];                //переставляем местами
            arr1[i + 1] = temp;
            count = 0;                            //обнулили счетчик, чтобы начать сначала внешний цикл
        }
        count++;                                  //за каждый проход цикла счетчик увеличивается на единицу.
    }                                             //если счетчик не обнуляется, то и перестановок не происходит,
}                                                 //а значит - элементы отсортированы

2. Пузырьковая сортировка:
Или сортировка простыми обменами. Бессмертная классика жанра. Принцип действий прост: обходим массив от начала до конца,
попутно меняя местами неотсортированные соседние элементы. В результате первого прохода на последнее место «всплывёт»
максимальный элемент. Теперь снова обходим неотсортированную часть массива (от первого элемента до предпоследнего) и меняем по
пути неотсортированных соседей. Второй по величине элемент окажется на предпоследнем месте. Продолжая в том же духе, будем
обходить всё уменьшающуюся неотсортированную часть массива, запихивая найденные максимумы в конец.

int countB = arr2.length;                         //завели переменную для контроля количества обхода внешним циклом                                 
while (countB != 0){                              
    for (int j = 0; j < arr2.length - 1; j++) {   //аналогичная перестановка элементов, как и в первом случае
        if (arr2[j] > arr2[j + 1]) {
            int temp = arr2[j];
            arr2[j] = arr2[j + 1];
            arr2[j + 1] = temp;
        }
        countB--;                                 //каждый раз будем уменьшать счетчик на 1, в результате элементы
    }                                             //отсортируются
}

3. Шейкерная сортировка:
Она же сортировка перемешиванием, она же коктейльная сортировка. Начинается процесс как в «пузырьке»: выдавливаем максимум
на самые задворки. После этого разворачиваемся на 1800 и идём в обратную сторону, при этом уже перекатывая в начало
не максимум, а минимум. Отсортировав в массиве первый и последний элементы, снова делаем кульбит. Обойдя туда-обратно несколько
раз, в итоге заканчиваем процесс, оказавшись в середине списка.

Шейкерная сортировка работает немного быстрее чем пузырьковая, поскольку по массиву в нужных направлениях попеременно
мигрируют и максимумы и минимумы. Улучшения, как говорится, налицо.

int countS = arr3.length;                                   //завели переменную для контроля внешнего главного цикла
while (countS != 0){                                        //После полного обхода массива внутренними циклами она будет
    for (int i = 0; i < arr3.length - countS; i++){         //каждый раз уменьшаться на 1
        if (arr3[i] > arr3[i + 1]) {                        //точно так же как и предыдущих примерах переставляем элементы
            int temp = arr3[i];                             //после сравнения.
            arr3[i] = arr3[i + 1];
            arr3[i + 1] = temp;                             //Это проход слева-направо
        }
    }
    countS--;                                               
    for (int j = arr3.length - countS; j > 0; j--){         //аналогично выполняется проход справа-налево
        if (arr3[j] < arr3[j - 1]){
            int temp = arr3[j];
            arr3[j] = arr3[j - 1];
            arr3[j - 1] = temp;
        }
    }
    countS--;                                               //и так до тех пор, пока переменная countB не будет равна нулю
}

4. Четно-нечетная сортировка
На сей раз мы не будем сновать по массиву взад-вперёд, а снова вернёмся к идее планомерного обхода слева-направо, но только
сделаем шире шаг. На первом проходе элементы с нечётным ключом сравниваем с соседями, зиждущимися на чётных местах 
(1-й сравниваем со 2-м, затем 3-й с 4-м, 5-й с 6-м и так далее). Затем наоборот – «чётные по счёту» элементы 
сравниваем/меняем с «нечётными». Затем снова «нечёт-чёт», потом опять «чёт-нечет». Процесс останавливается тогда, 
когда после подряд двух проходов по массиву («нечётно-чётному» и «чётно-нечётному») не произошло ни одного обмена. 
Стало быть, отсортировали.

В обычном «пузырьке» во время каждого прохода мы планомерно выдавливаем в конец массива текущий максимум. Если же передвигаться
вприпрыжку по чётным и нечётным индексам, то сразу все более-менее крупные элементы массива одновременно за один пробег 
проталкиваются вправо на одну позицию. Так получается быстрее.

boolean fst = false;                                        //инициализировали переменную fst, которая будет контролировать
while (fst != true){                                        //количество проходов внешнего цикла
    for (int i = 0; i < arr4.length - 1; i = i + 2){        //проход по четным элементам (i = i + 2), пропуская нечетные
        if (arr4[i] > arr4[i + 1]){                         //аналогичная замена соседних элементов
            int temp = arr4[i];
            arr4[i] = arr4[i + 1];
            arr4[i + 1] = temp;
        }
    }
    for (int j = 1; j < arr4.length - 1; j = j + 2){        //проход по нечетным элементам, пропуская четные
        if (arr4[j] > arr4[j + 1]){                         //перестановка элементов при необходимости
            int temp = arr4[j];
            arr4[j] = arr4[j + 1];
            arr4[j + 1] = temp;
        }
    }
    for (int k = 0; k < 3; k++){                            //проверочный цикл. Пока имеет место перестановка элементов,
        if (arr4[k] < arr4[k + 1]){                         
            fst = true;                                     //переменная будет равна true и завершение основного цикла
        }else {                                             //в противном случае:
            fst = false;                                    //fst = false
            break;                                          //выход из цикла дальнейший перебор элементов
        }
    }
}
