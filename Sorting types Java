Всем привет!
Решил освежить в памяти алгоритмы сортировки и их реализацию. Нашел на Хабре статью автора valemak (https://habr.com/post/204600/), буду брать выдержки его статьи и дополнять своим кодом. Данные механизмы сортировки являются разновидностями "сортировки обменом". Итак, приступим:

1. "Глупая" сортировка:
Просматриваем массив слева-направо и по пути сравниваем соседей. Если мы встретим пару взаимно неотсортированных элементов, то меняем их местами и возвращаемся на круги своя, то бишь в самое начало. Снова проходим-проверяем массив, если встретили снова «неправильную» пару соседних элементов, то меняем местами и опять начинаем всё сызнова. Продолжаем до тех пор пока массив потихоньку-полегоньку не отсортируется.

int count = 0;                                    //завели отдельный счетчик для внешнего цикла
while (count != arr1.length){                                                
    for (int i = 0; i < arr1.length - 1; i++){
        if (arr1[i] > arr1[i + 1]){               //встретили пару неотсортированных элементов
            int temp = arr1[i];                   //ввели временную переменную для запоминания одного из элементов
            arr1[i] = arr1[i + 1];                //переставляем местами
            arr1[i + 1] = temp;
            count = 0;                            //обнулили счетчик, чтобы начать сначала внешний цикл
        }
        count++;                                  //за каждый проход цикла счетчик увеличивается на единицу.
    }                                             //если счетчик не обнуляется, то и перестановок не происходит,
}                                                 //а значит - элементы отсортированы

2. Пузырьковая сортировка:
Или сортировка простыми обменами. Бессмертная классика жанра. Принцип действий прост: обходим массив от начала до конца, попутно меняя местами неотсортированные соседние элементы. В результате первого прохода на последнее место «всплывёт» максимальный элемент. Теперь снова обходим неотсортированную часть массива (от первого элемента до предпоследнего) и меняем по пути неотсортированных соседей. Второй по величине элемент окажется на предпоследнем месте. Продолжая в том же духе, будем обходить всё уменьшающуюся неотсортированную часть массива, запихивая найденные максимумы в конец.

int countB = arr2.length;                         //завели переменную для контроля количества обхода внешним циклом                                 
while (countB != 0){                              
    for (int j = 0; j < arr2.length - 1; j++) {   //аналогичная перестановка элементов, как и в первом случае
        if (arr2[j] > arr2[j + 1]) {
            int temp = arr2[j];
            arr2[j] = arr2[j + 1];
            arr2[j + 1] = temp;
        }
        countB--;                                 //каждый раз будем уменьшать счетчик на 1, в результате элементы
    }                                             //отсортируются
}
